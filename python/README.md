### ORD, CHR

- `ord(문자)` - 해당 문자의 아스키코드 값 정수 반환

- `chr(정수)` - 숫자 값에 해당하는 문자 반환

### 자료구조 호출

- `from collections import *`로 모든 자료구조 호출 가능

### 인접 행렬과 인접 리스트

- 그래프를 표현할 때의 방식 두가지이다.

- 그 중 인접 리스트가 일반적으로 그래프 문제를 사용하던 방식이다.

- 노드가 3개라면 3 x m 의 리스트를 생성한다.

- 2차원 인덱스는 노드의 번호를 의미하고 그 리스트에 담기는 내용은 그 노드와 연결된 노드와 그 노드까지 이동하는 데에 드는 비용이다.

- 예를 들면 0 -> 1 -> 2

### DFS

- 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.

- 스택의 최상단 노드, 그 노드와 연결된 인접한 노드 중 방문하지 않은 노드가 있으면 그 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 노드가 없으면 최상단 노드를 pop 한다.

- 위 과정을 더이상 할 수 없을 때 까지 반복한다.

### 선택 정렬

- 0번째부터 시작(i 포문), 0 + 1 번째부터 N번째까지 비교하면서(j 포문) 가장 작은 값과 자리를 서로 바꾼다.

- 위 과정을 n-1번까지 반복

### 삽입 정렬

- 1번째부터 시작(i 포문), 1 + 1 번째부터 0번째까지 비교하면서(j 포문) 현재 값이 갈 수 있는 한 최대한 앞으로 보낸다.(더 작은 값을 만나면 멈춘다.)

- 위 과정을 n-1번까지 반복

- 계속 가장 작은 값이 앞에 오고 오름차순을 유지하면서 정렬을 완성한다.

### 퀵 정렬

- 임의의 pivot을 정하고 그 pivot을 제외한 값들에 대해 로직을 수행한다.

- 왼쪽(앞)에서부터 pivot보다 큰 값을 찾고 오른쪽(뒤)에서부터 pivot보다 작은 값을 찾아서 서로 자리를 바꾼다.

- 위 과정을 서로 엇갈릴때까지 반복하고 엇갈릴 때 right 인덱스가 pivot이 갈 자리이므로 right와 pivot의 자리를 바꾼다.

- 그렇게되면 pivot을 기준으로 왼쪽은 pivot보다 작은 값들, 오른쪽은 pivot보다 큰 값들로 분할된다.

- 각 파티션에 똑같은 방식으로 pivot을 선정해서 정렬을 수행하도록 한다.

- 재귀로 반복하는데 종료 조건은 `start >= end`로 원소가 1개 뿐일때 종료한다. ***start, pivot, end는 모두 인덱스 값을 의미, 원소 값이 아님***